/* strtab */

/* string table object */


#define	CF_DEBUGS	0		/* compile-time debug print-outs */
#define	CF_DEBUGHDB	0		/* debug HDB sub-component */
#define	CF_SAFE1	1		/* safe-level=1 */
#define	CF_SAFE2	1		/* safe-level=2 (more safe) */
#define	CF_STRNLEN	0		/* use 'strnlen(3dam)' */


/* revision history:

	= 1998-03-24, David A­D­ Morano
        This object module was morphed from some previous one. I do not remember
        what the previous one was.

*/

/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

        This object module creates and manages a string table object. This
        string table can later be written to a file or otherwise stored some way
        so that it can be used in-place later. This is often useful for cache
        files or ELF code object files.

	Arguments:

	stp		pointer to the strtab object
	<others>

	Returns:

	>=0		the total length of the filled up strtab so far!
	<0		error


        Note: The index table (optionally) generated by this OBJECT using
        »hash-linking« to track down matches. It does not use »key-linking«.
        searching the generated index table must also use


*******************************************************************************/


#define	STRTAB_MASTER	0


#include	<envstandards.h>

#include	<sys/types.h>
#include	<unistd.h>
#include	<stdlib.h>
#include	<string.h>

#include	<vsystem.h>
#include	<vecobj.h>
#include	<localmisc.h>

#include	"strtab.h"


/* local defines */

#define	STRTAB_STARTSIZE	512	/* starting table size */
#define	STRTAB_NSKIP		5
#define	STRTAB_CHUNK		struct strtab_chunk

#if	STRTAB_ALLOCOBJ
#define	STRTAB_AOSTART(o,es,n)	allocobj_start((o),(es),(n))
#define	STRTAB_AOGET(o,pp)	allocobj_get((o),(pp))
#define	STRTAB_AOREL(o,pp)	allocobj_release((o),(pp))
#define	STRTAB_AOFINISH(o)	allocobj_finish((o))
#else /* STRTAB_ALLOCOBJ */
#define	STRTAB_AOSTART(o,es,n)	lookaside_start((o),(es),(n))
#define	STRTAB_AOGET(o,pp)	lookaside_get((o),(pp))
#define	STRTAB_AOREL(o,pp)	lookaside_release((o),(pp))
#define	STRTAB_AOFINISH(o)	lookaside_finish((o))
#endif /* STRTAB_ALLOCOBJ */

#define	MODP2(v,n)	((v) & ((n) - 1))

#define	VALBOGUS	(250000 * 10)


/* external subroutines */

extern uint	nextpowtwo(uint) ;
extern uint	hashelf(const void *,int) ;
extern uint	hashagain(uint,int,int) ;

extern int	iceil(int,int) ;

#if	CF_DEBUGS
extern int	debugprintf(const char *,...) ;
#endif

extern char	*strwcpy(char *,const char *,int) ;


/* local structures */

struct strentry {
	uint	khash ;
	uint	hi ;
	uint	si ;
} ;


/* forward references */

static int	strtab_stuff(STRTAB *,const char *,int) ;
static int	strtab_finishchunks(STRTAB *) ;
static int	strtab_extend(STRTAB *,int) ;
static int	strtab_newchunk(STRTAB *,int) ;

static int	chunk_start(STRTAB_CHUNK *,int,int) ;
static int	chunk_finish(STRTAB_CHUNK *) ;
static int	chunk_check(STRTAB_CHUNK *,int) ;
static int	chunk_add(STRTAB_CHUNK *,const char *,int,const char **) ;

static int	indexlen(int) ;
static int	indexsize(int) ;
static int	hashindex(uint,int) ;


/* local variables */


/* exported subroutines */


int strtab_start(op,startsize)
STRTAB		*op ;
int		startsize ;
{
	const int	pagesize = getpagesize() ;
	int		rs ;
	int		ne ;
	int		opts ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

	if (startsize < STRTAB_STARTSIZE)
	    startsize = STRTAB_STARTSIZE ;

	memset(op,0,sizeof(STRTAB)) ;

	ne = (startsize / 4) ;
	op->chunksize = iceil(startsize,pagesize) ;

	opts = 0 ;
	if ((rs = vechand_start(&op->chunks,ne,opts)) >= 0) {
	    if ((rs = hdb_start(&op->strdb,ne,TRUE,NULL,NULL)) >= 0) {
	        const int	size = sizeof(int) ;
	        if ((rs = STRTAB_AOSTART(&op->intdb,size,ne)) >= 0) {
	            op->count = 0 ;
	            if ((rs = strtab_newchunk(op,0)) >= 0) {
	                op->magic = STRTAB_MAGIC ;
	            }
	            if (rs < 0)
	                STRTAB_AOFINISH(&op->intdb) ;
	        }
	        if (rs < 0)
		    hdb_finish(&op->strdb) ;
	    }
	    if (rs < 0)
	        vechand_finish(&op->chunks) ;
	}

	return rs ;
}
/* end subroutine (strtab_start) */


/* free up this strtab object */
int strtab_finish(op)
STRTAB		*op ;
{
	int		rs = SR_OK ;
	int		rs1 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

#if	CF_DEBUGS /* small test */
	{
	    int	strsize ;
	    int	srsize ;
	    int	rs1 ;
	    int	n, i, si ;
	    int	*srtab ;
	    char	*stab ;
	    strsize = strtab_strsize(op) ;
	    debugprintf("strtab_finish: _strsize() rs=%d\n",strsize) ;
	    if (uc_malloc(strsize,&stab) >= 0) {
	        rs1 = strtab_strmk(op,stab,strsize) ;
	        debugprintf("strtab_finish: _strmk() rs=%d\n",rs1) ;
	        if (rs1 >= 0) {
	            srsize = strtab_recsize(op) ;
	            debugprintf("strtab_finish: _recsize() rs=%d\n",srsize) ;
	            if (uc_malloc(srsize,&srtab) >= 0) {
	                rs1 = strtab_recmk(op,srtab,srsize) ;
	                debugprintf("strtab_finish: _recmk() rs=%d\n",rs1) ;
	                n = strtab_count(op) ;
	                for (i = 0 ; i < (n+1) ; i += 1) {
	                    si = srtab[i] ;
	                    if (si > 0)
	                        debugprintf("strtab_finish: "
	                            "si=%u s%u=%s\n",si,i,(stab+si)) ;
	                }
	                uc_free(srtab) ;
	            } /* end if (memory-allocation) */
	        }
	        uc_free(stab) ;
	    } /* end if (memory-allocation) */
	}
#endif /* CF_DEBUGS */

	rs1 = STRTAB_AOFINISH(&op->intdb) ;
	if (rs >= 0) rs = rs1 ;

	rs1 = hdb_finish(&op->strdb) ;
	if (rs >= 0) rs = rs1 ;

	rs1 = strtab_finishchunks(op) ;
	if (rs >= 0) rs = rs1 ;

	rs1 = vechand_finish(&op->chunks) ;
	if (rs >= 0) rs = rs1 ;

	op->magic = 0 ;
	return rs ;
}
/* end subroutine (strtab_finish) */


/* add a character-string */
int strtab_add(op,sp,sl)
STRTAB		*op ;
const char	*sp ;
int		sl ;
{
	HDB_DATUM	key, val ;
	int		rs ;
	int		vi = 0 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

	if (sp == NULL) return SR_FAULT ;

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

#if	CF_STRNLEN
	sl = strnlen(sp,sl) ;
#else
	if (sl < 0) sl = strlen(sp) ;
#endif

#if	CF_DEBUGS
	debugprintf("strtab_add: s=%t sl=%u strtab::len=%u\n",
	    sp,strnlen(sp,sl),sl,op->stlen) ;
#endif

/* do we have it already? */

	key.buf = sp ;
	key.len = sl ;
	if ((rs = hdb_fetch(&op->strdb,key,NULL,&val)) >= 0) {
	    int	*ip = (int *) val.buf ;

	    vi = *ip ;

#if	CF_DEBUGS
	    debugprintf("strtab_add: already vi=%u\n",vi) ;
	    if (vi > VALBOGUS) {
	        debugprintf("strtab_add: BOGUS-val\n") ;
	        debugprintf("strtab_add: s=%t\n",sp,sl) ;
	        debugprintf("strtab_add: ALREADY bogus vi=%u\n",vi) ;
	        rs = SR_BADFMT ;
	    }
#endif /* CF_DEBUGS */

	} else if (rs == SR_NOTFOUND) {
	    rs = strtab_stuff(op,sp,sl) ;
	    vi = rs ;
	} /* end if */

#if	CF_DEBUGS
	debugprintf("strtab_add: ret rs=%d vi=%u\n",rs,vi) ;
#endif

	return (rs >= 0) ? vi : rs ;
}
/* end subroutine (strtab_add) */


/* fast-add a character string */
int strtab_addfast(op,sp,sl)
STRTAB		*op ;
const char	*sp ;
int		sl ;
{
	int		rs ;
	int		vi = 0 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

#if	CF_STRNLEN
	sl = strnlen(sp,sl) ;
#else
	if (sl < 0) sl = strlen(sp) ;
#endif

	rs = strtab_stuff(op,sp,sl) ;
	vi = rs ;

#if	CF_DEBUGS
	debugprintf("strtab_addfast: ret rs=%d vi=%u\n",rs,vi) ;
#endif

	return (rs >= 0) ? vi : rs ;
}
/* end subroutine (strtab_addfast) */


/* is a given string already represented? */
int strtab_already(op,sp,sl)
STRTAB		*op ;
const char	sp[] ;
int		sl ;
{
	HDB_DATUM	key, val ;
	int		rs ;
	int		vi = 0 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

	if (sp == NULL) return SR_FAULT ;

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

#if	CF_STRNLEN
	sl = strnlen(sp,sl) ;
#else
	if (sl < 0) sl = strlen(sp) ;
#endif

/* do we have it already? */

	key.buf = sp ;
	key.len = sl ;
	if ((rs = hdb_fetch(&op->strdb,key,NULL,&val)) >= 0) {
	    int	*ip = (int *) val.buf ;

	    vi = *ip ;

#if	CF_DEBUGS
	    if (vi > VALBOGUS) {
	        debugprintf("strtab_already: s=%t\n",sp,sl) ;
	        debugprintf("strtab_already: ALREADY bogus vi=%u\n",vi) ;
	    }
#endif

	} /* end if */

	return (rs >= 0) ? vi : rs ;
}
/* end subroutine (strtab_already) */


/* get the string count in the table */
int strtab_count(op)
STRTAB		*op ;
{

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	return op->count ;
}
/* end subroutine (strtab_count) */


int strtab_strsize(op)
STRTAB		*op ;
{
	int		size ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	size = iceil(op->stlen,sizeof(int)) ;

	return size ;
}
/* end subroutine (strtab_strsize) */


/* make the string table */
int strtab_strmk(op,tabdata,tabsize)
STRTAB		*op ;
char		tabdata[] ;
int		tabsize ;
{
	STRTAB_CHUNK	*ccp ;
	int		size ;
	int		i ;
	int		c = 0 ;
	char		*bp = tabdata ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	if (tabdata == NULL) return SR_FAULT ;

	size = iceil(op->stlen,sizeof(int)) ;

	if (tabsize < size)
	    return SR_OVERFLOW ;

	for (i = 0 ; vechand_get(&op->chunks,i,&ccp) >= 0 ; i += 1) {
	    if (ccp == NULL) continue ;

	    if (ccp->cdata != NULL) {
	        c += 1 ;
	        memcpy(bp,ccp->cdata,ccp->cl) ;
	        bp += ccp->cl ;
	    }

	} /* end for */

	while (bp < (tabdata + tabsize))
	    *bp++ = '\0' ;

	return c ;
}
/* end subroutine (strtab_strmk) */


/* calculate the index table length (entries) */
int strtab_recsize(op)
STRTAB		*op ;
{
	int		n ;
	int		size ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	n = (op->count + 1) ;
	size = (n + 1) * sizeof(int) ;
	return size ;
}
/* end subroutine (strtab_recsize) */


/* make the record table */
int strtab_recmk(op,rec,recsize)
STRTAB		*op ;
int		rec[] ;
int		recsize ;
{
	int		rs ;
	int		n, size ;
	int		c = 0 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	n = (op->count + 1) ;
	size = (n + 1) * sizeof(int) ;
	if (recsize >= size) {
	    HDB_CUR	cur ;
	    HDB_DATUM	key, val ;
	    int	*ip ;
	    rec[c++] = 0 ;			/* ZERO-entry is NUL-string */
	    if ((rs = hdb_curbegin(&op->strdb,&cur)) >= 0) {
	        while (hdb_enum(&op->strdb,&cur,&key,&val) >= 0) {
	            ip = (int *) val.buf ;
	            rec[c++] = *ip ;
	        } /* end while (looping through strings) */
	        hdb_curend(&op->strdb,&cur) ;
	    } /* end if */
	    rec[c] = -1 ;
	} else
	    rs = SR_OVERFLOW ;

	return (rs >= 0) ? c : rs ;
}
/* end subroutine (strtab_recmk) */


/* calculate the index table length (entries) */
int strtab_indlen(op)
STRTAB		*op ;
{
	int		il ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

#if	CF_DEBUGS
	debugprintf("strtab_indlen: c=%u\n",op->count) ;
#endif

	il = indexlen(op->count + 1) ;

#if	CF_DEBUGS
	debugprintf("strtab_indlen: ret il=%u\n",il) ;
#endif

	return il ;
}
/* end subroutine (strtab_indlen) */


/* calculate the index table size */
int strtab_indsize(op)
STRTAB		*op ;
{
	int		isize ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	{
	    int il = indexlen(op->count + 1) ;
	    isize = indexsize(il) ;
	}

	return isize ;
}
/* end subroutine (strtab_indsize) */


/* make an index table of the string table */
int strtab_indmk(op,it,itsize,nskip)
STRTAB		*op ;
int		(*it)[3] ;
int		itsize ;
int		nskip ;
{
	VECOBJ		ses ;
	uint		khash, chash, nhash ;
	const int	esize = sizeof(struct strentry) ;
	int		rs ;
	int		lhi, nhi, hi, si ;
	int		il ;
	int		isize ;
	int		opts ;
	int		sc = 0 ;

#if	CF_SAFE1
	if (op == NULL) return SR_FAULT ;
#endif

#if	CF_SAFE2
	if (op->magic != STRTAB_MAGIC) return SR_NOTOPEN ;
#endif

	if (nskip < 0)
	    nskip = 0 ;

	il = indexlen(op->count + 1) ;

	isize = indexsize(il) ;

	if (itsize < isize)
	    return SR_OVERFLOW ;

/* start in */

	memset(it,0,isize) ;

	opts = VECOBJ_OCOMPACT ;
	if ((rs = vecobj_start(&ses,esize,op->count,opts)) >= 0) {
	    struct strentry	se, *sep ;
	    HDB_CUR	cur ;
	    HDB_DATUM	key, val ;

	    if ((rs = hdb_curbegin(&op->strdb,&cur)) >= 0) {
		int		*ip ;
		int		sl ;
		const char	*sp ;

	        while ((sl = hdb_enum(&op->strdb,&cur,&key,&val)) >= 0) {

	            sp = (const char *) key.buf ;
	            sl = key.len ;

	            ip = (int *) val.buf ;
	            si = *ip ;
	            khash = hashelf(sp,sl) ;

	            hi = hashindex(khash,il) ;

	            if (it[hi][0] == 0) {

	                it[hi][0] = si ;
	                it[hi][1] = (khash & INT_MAX) ;
	                it[hi][2] = 0 ;
	                sc += 1 ;

	            } else {

	                se.khash = khash ;
	                se.si = si ;
	                se.hi = hi ;
	                rs = vecobj_add(&ses,&se) ;

	            } /* end if */

	            if (rs < 0) break ;
	        } /* end while (looping through strings) */

	        hdb_curend(&op->strdb,&cur) ;
	    } /* end if (cursor) */

	    if (rs >= 0) {
		int	i ;
		int	c ;

	        for (i = 0 ; vecobj_get(&ses,i,&sep) >= 0 ; i += 1) {

	            khash = sep->khash ;
	            si = sep->si ;
	            hi = sep->hi ;

	            chash = (khash & INT_MAX) ;
	            nhash = khash ;

	            c = 0 ;
	            while (it[hi][0] > 0) {

	                if ((it[hi][1] & INT_MAX) == chash)
	                    break ;

	                it[hi][1] |= (~ INT_MAX) ;
	                nhash = hashagain(nhash,c,nskip) ;

	                hi = hashindex(nhash,il) ;

	                c += 1 ;

	            } /* end while */

	            sc += c ;
	            if (it[hi][0] > 0) {

	                lhi = hi ;
	                while ((nhi = it[lhi][2]) > 0)
	                    lhi = nhi ;

	                hi = hashindex((lhi + 1),il) ;

	                while (it[hi][0] > 0)
	                    hi = hashindex((hi + 1),il) ;

	                it[lhi][2] = hi ;

	            } /* end while */

	            it[hi][0] = si ;
	            it[hi][1] = chash ;
	            it[hi][2] = 0 ;

	        } /* end for */

	        it[il][0] = -1 ;
	        it[il][1] = 0 ;
	        it[il][2] = 0 ;

	        if (sc < 0)
	            sc = 0 ;

	    } /* end if */

	    vecobj_finish(&ses) ;
	} /* end if (vecobj) */

	return (rs >= 0) ? sc : rs ;
}
/* end subroutine (strtab_indmk) */


/* private subroutines */


/* store a string into the table */
static int strtab_stuff(op,sp,sl)
STRTAB		*op ;
const char	*sp ;
int		sl ;
{
	int		rs ;
	int		amount ;
	int		vi = 0 ;

/* do we need to extend the table? */

	amount = (sl + 1) ;
	if ((rs = strtab_extend(op,amount)) >= 0) {
	    const char	*vp = NULL ;
	    vi = op->stlen ;
	    if ((rs = chunk_add(op->ccp,sp,sl,&vp)) >= 0) {
		int	*ip ;
	        if ((rs = STRTAB_AOGET(&op->intdb,&ip)) >= 0) {
		    HDB_DATUM	key, val ;
	            *ip = vi ;
	            key.buf = vp ;
	            key.len = sl ;
	            val.buf = ip ;
	            val.len = sizeof(int) ;
	            if ((rs = hdb_store(&op->strdb,key,val)) >= 0) {
	                op->stlen += amount ;
	                op->count += 1 ;
	            }
	        } /* end if (AOGET) */
	    } /* end if (chunk-add) */
	} /* end if (extend) */

#if	CF_DEBUGS
	debugprintf("strtab_stuff: ret rs=%d val=%u\n",rs,val) ;
#endif

	return (rs >= 0) ? vi : rs ;
}
/* end subroutine (strtab_stuff) */


/* free up all of the chunks */
static int strtab_finishchunks(op)
STRTAB		*op ;
{
	STRTAB_CHUNK	*ccp ;
	int		rs = SR_OK ;
	int		rs1 ;
	int		i ;
	int		c = 0 ;

	for (i = 0 ; vechand_get(&op->chunks,i,&ccp) >= 0 ; i += 1) {
	    if (ccp == NULL) continue ;

	    c += 1 ;
	    rs1 = chunk_finish(ccp) ;
	    if (rs >= 0) rs = rs1 ;

	    rs1 = uc_free(ccp) ;
	    if (rs >= 0) rs = rs1 ;

	} /* end for */

#if	CF_DEBUGS
	debugprintf("strtab_finishchunks: cs=%u chunks_freed=%u\n",
	    op->chunksize,c) ;
#endif

	op->ccp = NULL ;
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (strtab_finishchunks) */


/* extend the string table */
static int strtab_extend(op,amount)
STRTAB		*op ;
int		amount ;
{
	int		rs = SR_OK ;
	int		rs1 ;

	if (op->ccp != NULL) {

#if	CF_DEBUGS
	    debugprintf("strtab_extend: chunk_check() \n") ;
#endif

	    rs1 = chunk_check(op->ccp,amount) ;
	    if (rs1 < 0)
	        op->ccp = NULL ;

	} /* end if (tried to extend a chunk) */

	if (op->ccp == NULL) {

#if	CF_DEBUGS
	    debugprintf("strtab_extend: strtab_newchunk() \n") ;
#endif

	    rs = strtab_newchunk(op,amount) ;
	}

	return rs ;
}
/* end subroutine (strtab_extend) */


static int strtab_newchunk(op,amount)
STRTAB		*op ;
int		amount ;
{
	int		rs ;
	int		size ;
	int		start = 0 ;

#if	CF_DEBUGS
	debugprintf("strtab_newchunk: ent\n") ;
#endif

	op->ccp = NULL ;
	size = sizeof(STRTAB_CHUNK) ;
	if ((rs = uc_malloc(size,&op->ccp)) >= 0) {
	    if (op->stlen == 0) {
	        op->stlen = 1 ;
	        start = 1 ;
	    }
	    if (amount < op->chunksize) amount = op->chunksize ;
	    if ((rs = chunk_start(op->ccp,amount,start)) >= 0) {
		rs = vechand_add(&op->chunks,op->ccp) ;
		if (rs < 0)
		    chunk_finish(op->ccp) ;
	    }
	    if (rs < 0) {
	        uc_free(op->ccp) ;
	        op->ccp = NULL ;
	    }
	} /* end if (memory-allocation) */

	return rs ;
}
/* end subroutine (strtab_newchunk) */


static int chunk_start(ccp,chunksize,start)
STRTAB_CHUNK	*ccp ;
int		chunksize ;
int		start ;
{
	int		rs = SR_OK ;

#if	CF_DEBUGS
	debugprintf("chunk_start: start=%u\n",start) ;
#endif

	if (chunksize < STRTAB_MINCHUNKSIZE) chunksize = STRTAB_MINCHUNKSIZE ;

	memset(ccp,0,sizeof(STRTAB_CHUNK)) ;
	if (start > chunksize) chunksize = start ;

	if ((rs = uc_malloc(chunksize,&ccp->cdata)) >= 0) {
	    ccp->csize = chunksize ;
	    ccp->cdata[0] = '\0' ;
	    ccp->cl = start ;
	}

	return rs ;
}
/* end subroutine (chunk_start) */


static int chunk_finish(ccp)
STRTAB_CHUNK	*ccp ;
{
	int		rs = SR_OK ;
	int		rs1 ;

	if (ccp->cdata != NULL) {
	    rs1 = uc_free(ccp->cdata) ;
	    if (rs >= 0) rs = rs1 ;
	    ccp->cdata = NULL ;
	}

	ccp->csize = 0 ;
	ccp->cl = 0 ;
	return rs ;
}
/* end subroutine (chunk_finish) */


static int chunk_check(ccp,amount)
STRTAB_CHUNK	*ccp ;
int		amount ;
{
	int		rs = SR_OK ;

	if (amount > (ccp->csize - ccp->cl))
	    rs = SR_OVERFLOW ;

	return rs ;
}
/* end subroutine (chunk_check) */


static int chunk_add(ccp,sp,sl,spp)
STRTAB_CHUNK	*ccp ;
const char	sp[] ;
int		sl ;
const char	**spp ;
{
	int		rs = SR_OK ;
	int		amount = (sl + 1) ;

	*spp = NULL ;

#if	CF_DEBUGS
	debugprintf("strtab/chunk_add: tl=%u s=%t\n",
	    ccp->cl,sp,sl) ;
#endif

	if (amount <= (ccp->csize - ccp->cl)) {
	    char	*bp = (ccp->cdata + ccp->cl) ;
	    *spp = bp ;
	    strwcpy(bp,sp,sl) ;
	    ccp->cl += amount ;
	    ccp->count += 1 ;
	} else
	    rs = SR_NOANODE ;

	return rs ;
}
/* end subroutine (chunk_add) */


static int indexlen(n)
int		n ;
{
	int		il = nextpowtwo(n) ;
	return il ;
}
/* end subroutine (indexlen) */


static int indexsize(il)
int		il ;
{
	int		isize = (il + 1) * 3 * sizeof(int) ;
	return isize ;
}
/* end subroutine (indexsize) */


/* calculate the next hash from a given one */
static int hashindex(hv,n)
uint		hv ;
int		n ;
{
	int		hi = MODP2(hv,n) ;
	if (hi == 0) hi = 1 ;
	return hi ;
}
/* end subroutine (hashindex) */



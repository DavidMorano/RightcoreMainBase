template <typename T>
stree_iterator<T>& stree_iterator<T>::operator++ ()
{
 stnode<T> *p;

 if (nodePtr == NULL)
   {
   // ++ from end(). get the root of the tree
   nodePtr = tree->root;
   
   // error! ++ requested for an empty tree
   if (nodePtr == NULL)
     throw
       underflowError("stree iterator operator++ (): tree empty");
   
   // move to the smallest value in the tree,
   // which is the first node inorder
   while (nodePtr->left != NULL) {
     nodePtr = nodePtr->left;
     }
   }
 else
   if (nodePtr->right != NULL)
     {
      // successor is the furthest left node of
      // right subtree
      nodePtr = nodePtr->right;
     
      while (nodePtr->left != NULL) {
        nodePtr = nodePtr->left;
        }
     }
   else
     {
       // have already processed the left subtree, and
       // there is no right subtree. move up the tree,
       // looking for a parent for which nodePtr is a left child,
       // stopping if the parent becomes NULL. a non-NULL parent
       // is the successor. if parent is NULL, the original node
       // was the last node inorder, and its successor
       // is the end of the list
       p = nodePtr->parent;
       while (p != NULL && nodePtr == p->right)
         {
           nodePtr = p;
           p = p->parent;
         }
       
       // if we were previously at the right-most node in
       // the tree, nodePtr = NULL, and the iterator specifies
       // the end of the list
       nodePtr = p;
     }

 return *this;
}


